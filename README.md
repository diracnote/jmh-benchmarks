# jmh-benchmarks

Some collections of jmh benchmarks for Java.

## Build

Build the package with Maven:

```bash
mvn package
```
## Benchmarks

### Reflection

Benchmark to test the cost between method call and reflection method invoke. Original from [nfrankel](https://github.com/nfrankel/reflection-performance), you can find the discussion [here](https://www.reddit.com/r/java/comments/4wkzck/performance_cost_of_reflection/).

#### Differences from original case

 - excludes test for ReflectASM
 - replace Field.get() by Method.invoke()
 - simplify Person interface (additional Date field wont add more cost?)
 - make method return original object, not array of object, which will create new instance of array (expensive, add 10± ns/ops, which explains nfrankel's result)
 - change benchmark mode to Mode.AverageTime
 - add some test for Method.invoke() and Field.get()

#### Run

```bash
java -jar reflection/target/benchmarks.jar
```

#### Benchmark result

Check the file `reflection\reflection.benchmark` for the detail log of JMH.

```bash
Benchmark                                                         Mode  Cnt   Score   Error  Units
JmhBenchmark.Immutable_Interface_Direct                           avgt  200   4.950 ± 0.053  ns/op
JmhBenchmark.Immutable_Interface_Reflection                       avgt  200  23.306 ± 0.184  ns/op
JmhBenchmark.Immutable_Interface_Reflection_WithoutSetAccessible  avgt  200  76.700 ± 0.457  ns/op
JmhBenchmark.Immutable_Object_Direct                              avgt  200   4.930 ± 0.050  ns/op
JmhBenchmark.Immutable_Object_Reflection                          avgt  200  20.495 ± 0.129  ns/op
JmhBenchmark.Instance_getClass                                    avgt  200   4.763 ± 0.031  ns/op
JmhBenchmark.Mutable_Interface_Direct                             avgt  200   4.900 ± 0.038  ns/op
JmhBenchmark.Mutable_Interface_Reflection                         avgt  200  23.276 ± 0.243  ns/op
JmhBenchmark.Mutable_Interface_Reflection_WithoutSetAccessible    avgt  200  76.712 ± 0.533  ns/op
JmhBenchmark.Mutable_Object_Direct                                avgt  200   4.876 ± 0.033  ns/op
JmhBenchmark.Mutable_Object_Field_Reflection                      avgt  200  69.946 ± 0.381  ns/op
JmhBenchmark.Mutable_Object_Reflection                            avgt  200  20.445 ± 0.116  ns/op
JmhBenchmark.New_Object_Array                                     avgt  200  10.314 ± 0.106  ns/op
JmhBenchmark.Unsafe_Ensure                                        avgt  200  58.680 ± 0.314  ns/op
JmhBenchmark.Unsafe_getObject                                     avgt  200   5.204 ± 0.034  ns/op
```

#### Notes

##### Method.invoke()
With `setAccessible`, `Method.invoke()` can avoid access check (private, public, etc). `Method.invoke` call method by `DelegatingMethodAccessorImpl`, which will call `NativeMethodAccessorImpl` at the beginning. After **15 calls** (controlled by `ReflectionFactory.inflationThreshold`, can be modified by property '`sun.reflect.inflationThreshold`'), NativeMethodAccessorImpl will generate new proxy class (`reflection\src\resources\sun\reflect\GeneratedMethodAccessor1.class`) to call directly. The proxy class is generated by `MethodAccessorGenerator` and will replace the NativeMethodAccessorImpl instance in DelegatingMethodAccessorImpl. So, Method.invoke only add 3 more method calls.

##### Field.get()
`Field.get()` can use setAccessible to override access check too, but Java still need to check whether the param is a instance of the Field's Class. The check happens in `UnsafeFieldAccessorImpl.ensureObj()` and use `isAssignableFrom()` which is costly. Get object from jvm (`JmhBenchmark.Unsafe_getObject`), on the other hand, is fast as method call.
